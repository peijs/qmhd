

悲观锁(Pessimistic Lock), 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，
这样别人想拿这个数据就会block(阻塞)，直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，
比如行锁、表锁、读锁、写锁等，都是在做操作之前先上锁。

乐观锁(Optimistic Lock)，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候
会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这
样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

--------------------------------------------------------------------------------------------------
悲观锁的实现方式:

在整个数据的处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制，因为只有
数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保
证外部系统不会修改数据。

--------------------------------------------------------------------------------------------------
乐观锁的实现方式:

1.使用整数表示数据版本号。(这是乐观锁最常用的一种实现方式)
  在Table中增加一个数字类型的字段(version)来记录数据版本。读取数据时，将version字段读出，数
  据每更新一次，对此version值+1。提交更新时，判断Table中对应记录(行)的version值与之前读取出
  来的version值是否一致，如果一致则予以更新，并且把version值+1，否则认为是过期数据。

2.使用时间戳来实现。
  在需要乐观锁控制的table中增加一个字段(名称无所谓)，字段类型使用时间戳(timestamp)，和上面的
  version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，
  如果一致则OK，否则就是版本冲突。

注: 对于以上两种方式，Hibernate自带实现方式: 在使用乐观锁的字段前加annotation: @Version, 
    Hibernate在更新时自动校验该字段。
